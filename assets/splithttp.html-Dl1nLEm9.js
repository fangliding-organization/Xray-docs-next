import{_ as c,r as s,o as l,c as r,d as o,a as e,b as t,e as a}from"./app-D-aWyVF7.js";const d={},i=e("h1",{id:"splithttp",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#splithttp"},[e("span",null,"SplitHTTP")])],-1),u=a(`<p>使用HTTP分块传输编码下载，使用多个HTTP POST请求进行上传。</p><p>可以通过不支持WebSocket的CDN上，但仍有一些要求：</p><ul><li>CDN必须支持HTTP分块传输，且支持流式响应不会缓冲，核心将会发送 <code>X-Accel-Buffering: no</code> 以及 <code>Content-Type: text/event-stream</code> 以告知CDN，但是需要CDN遵守此标头。如果中间盒不支持流式响应而导致连接被挂起，则该传输很可能无法工作。</li></ul><p>目的与V2fly Meek相同，由于使用了分块下载，下行速率更为优秀，上行也经过优化但仍非常有限，也因此对 HTTP 中间盒要求更高（见上）。</p><p><code>SplitHTTP</code> 也接受 <code>X-Forwarded-For</code> header。</p><h2 id="splithttpobject" tabindex="-1"><a class="header-anchor" href="#splithttpobject"><span>SplitHttpObject</span></a></h2><p>The <code>SplitHttpObject</code> 对应传输配置的 <code>splithttpSettings</code> 项。</p><div class="language-json line-numbers-mode" data-ext="json" data-title="json"><pre class="language-json"><code><span class="token punctuation">{</span>
  <span class="token property">&quot;path&quot;</span><span class="token operator">:</span> <span class="token string">&quot;/&quot;</span><span class="token punctuation">,</span>
  <span class="token property">&quot;host&quot;</span><span class="token operator">:</span> <span class="token string">&quot;xray.com&quot;</span><span class="token punctuation">,</span>
  <span class="token property">&quot;headers&quot;</span><span class="token operator">:</span> <span class="token punctuation">{</span>
    <span class="token property">&quot;key&quot;</span><span class="token operator">:</span> <span class="token string">&quot;value&quot;</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token property">&quot;maxUploadSize&quot;</span><span class="token operator">:</span> <span class="token number">1000000</span><span class="token punctuation">,</span>
  <span class="token property">&quot;maxConcurrentUploads&quot;</span><span class="token operator">:</span> <span class="token number">10</span> 
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote><p><code>path</code>: string</p></blockquote><p>SplitHTTP 所使用的 HTTP 协议路径，默认值为 <code>&quot;/&quot;</code>。</p><blockquote><p><code>host</code>: string</p></blockquote><p>SplitHTTP 的HTTP请求中所发送的host，默认值为空。若服务端值为空时，不验证客户端发送来的host值。</p><p>当在服务端指定该值，或在 <code>headers</code> 中指定host，将会校验与客户端请求host是否一致。</p><p>客户端选择发送的host优先级 <code>host</code> &gt; <code>headers</code> &gt; <code>address</code></p><blockquote><p><code>headers</code>: map {string: string}</p></blockquote><p>自定义 HTTP 头，一个键值对，每个键表示一个 HTTP 头的名称，对应的值是字符串。</p><blockquote><p><code>maxUploadSize</code>: int</p></blockquote><p>上传分块的最大大小，单位为字节，默认为 1 MB.</p><p>这个值应该小于CDN或其他HTTP反向代理所允许的最大请求体，否则将抛出 HTTP 413 错误。</p><p>适当提升这个值可以增加上传速率。</p><blockquote><p><code>maxConcurrentUploads</code>: int</p></blockquote><p>上传连接的最大并发数，默认为10, 连接将尽可能被重用。</p><p>如果连接不稳定或者服务端内存占用过高可以尝试调低。</p><p>客户端所设定的值必须低于服务端，否则可能导致连接问题。</p><h2 id="协议细节" tabindex="-1"><a class="header-anchor" href="#协议细节"><span>协议细节</span></a></h2>`,25),h={href:"https://github.com/XTLS/Xray-core/pull/3412",target:"_blank",rel:"noopener noreferrer"},T={href:"https://github.com/XTLS/Xray-core/pull/3462",target:"_blank",rel:"noopener noreferrer"},k=a("<ol><li><p>使用 <code>GET /&lt;UUID&gt;</code> 开始下载。服务器立即回复 <code>200 OK</code> 和 <code>Transfer Encoding:chunked</code> , 并立即发送一个两字节的有效负载，以强制HTTP中间盒刷新标头。</p></li><li><p>使用 <code>POST /&lt;UUID&gt;/&lt;seq&gt;</code> 开始发送上行数据. <code>seq</code> 作用类似于 TCP 序列号，从0开始，数据包可以被同时发送，服务端必须按序列号将数据重组。序列号不应重置。</p><p>客户端可以以任意决定打开上行与下行请求的顺序，任何一种都可以启动会话，但是必须要在30秒内打开 <code>GET</code> 连接，否则会话将被终止。</p></li><li><p><code>GET</code> 请求将一直保持在打开状态直到连接被终止，服务端和客户端都可以关闭连接。具体行为取决于HTTP版本。</p></li></ol><p>建议:</p><ul><li><p>不要期望CDN会正确传输所有标头，这个协议的目的是为了穿透不支持WS的CDN，而这些CDN的行为通常不怎么友好。</p></li><li><p>应当假设所有HTTP连接都不支持流式请求，所以上行连接发送的的每个包的大小应该基于延迟、吞吐量以及中间盒本身的限制考虑(类似TCP的MTU与纳格算法)。</p></li><li><p>关于HTTP版本，核心暂时未支持 h2c，故未使用 HTTPS 时 Xray 仅会发送 http/1.1 请求。 为了避免ALPN协商造成的额外复杂性，Xray客户端在使用 HTTPS 时使用 h2 (除非在 tlsSettings 中手动指定 alpn 为 http/1.1 )，Xray服务端则兼容各种类型的入站连接(暂时没有h3)，因为入站连接可以由于中间盒而出现各种类型的请求。</p></li></ul>",3);function b(m,q){const p=s("Badge"),n=s("ExternalLinkIcon");return l(),r("div",null,[i,o(p,{text:"v1.8.16+",type:"warning"}),u,e("p",null,[t("讨论详见 "),e("a",h,[t("#3412"),o(n)]),t(" 和 "),e("a",T,[t("#3462"),o(n)]),t(" 以下是简述和简要兼容实现要求")]),k])}const _=c(d,[["render",b],["__file","splithttp.html.vue"]]);export{_ as default};
